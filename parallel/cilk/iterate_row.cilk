#include "common.h"
#include <omp.h>
#include <sys/time.h>
#include <cilk-lib.cilkh>

#define min(x,y) (x)<(y)?(x):(y)


static void update(double **primary, double **secondary, int j, int k, double **vectors);
cilk static void update_chunk(double **primary, double **secondary, int j, double **vectors, int depth, int min, int max);

cilk void iterate(double **primary, double **vectors)
{
  double start, finish, usec_diff;
  int i,j,k; 
  double **secondary = malloc(options.n * sizeof(double*));
  if (secondary == NULL){
    bail_out(EXIT_FAILURE, "malloc secondary");
  }
  for (i = 0; i < options.n; i++){
    secondary[i] = calloc(options.m, sizeof(double));
    if (secondary[i] == NULL){
      bail_out(EXIT_FAILURE, "malloc secondary[%d]", i);
    }
  }

  start = omp_get_wtime();
  for (i = 0; i < options.iter; i++){
    double **temp;
    for(j = 0; j < options.n; j++){
      spawn update_chunk(primary, secondary, j, vectors, 1, 0, options.m);
    }
    sync;
    temp = primary;
    primary = secondary;
    secondary = temp;
  }
  finish = omp_get_wtime();
  
  usec_diff = finish - start;
  fprintf(stderr,"loop time = %f\n", usec_diff);
  
  if (options.iter % 2 == 1){
    double **temp = primary;
    primary = secondary;
    secondary = temp;
    for (i = 0; i < options.n; i++){
      memcpy(primary[i],secondary[i],options.m * sizeof(double));
    } 
  }
  
  for (i = 0; i < options.n; i++){
    free(secondary[i]);
  }
  free(secondary);
}
static void update(double **primary, double **secondary, int j, int k, double **vectors){
  double sum = 0;
  debug("update %d %d\n", j, k);


  if (k-1 < 0) {
    sum += vectors[3][j];
  }
  else{
    sum += primary[j][k-1];
  }

  if (j-1 < 0) {
    sum += vectors[0][k];
  }
  else{
    sum += primary[j-1][k];
  }

  if (k+1 >= options.m) {
    sum += vectors[1][j];
  }
  else{
    sum += primary[j][k+1];
  }

  if (j+1 >= options.n) {
    sum += vectors[2][k];
  }
  else{
    sum += primary[j+1][k];
  }

  secondary[j][k] = sum/(double)4;
}

cilk static void update_chunk(double **primary, double **secondary, int j, double **vectors, int depth, int min, int max){
  int k;
  int chunk_value = options.m/(8*Cilk_active_size) + 1; 
  int chunksize = min(2048, chunk_value);
  //printf("length = %d, 8* processors = %d\n", options.m, 8*Cilk_active_size);
  //printf("processors = %d, chunk_value = %d, chunksize = %d\n", Cilk_active_size, chunk_value, chunksize);
  //printf("row = %d, min = %d, max = %d\n", j ,min, max);
  if (Cilk_active_size < (options.n * depth) || max-min < chunksize*2){ 
    //printf("processors = %d, rows = %d\n", Cilk_active_size, options.n * depth);
    for(k = min; k < max; k++){
      update(primary, secondary, j, k, vectors);
    }
  }
  else{
    int mid = (min + max)/2;   
    spawn update_chunk(primary, secondary, j, vectors, depth+1, min, mid);
    spawn update_chunk(primary, secondary, j, vectors, depth+1, mid, max);
  }
}
